import { PlaylistJSON, YtdlPlaylistDownloader } from "./ytdl";
import express, { Response, Request } from "express";
import * as fs from "fs";
import humanizeDuration from "humanize-duration";
import cors from "cors";
import md5 from "object-hash";
const app = express();
const port = 6060; // default port to listen
const playlistDirectory = "./playlist_data";
const playlists = new Map<string, PlaylistJSON>();
const playlistHashes = new Map<string, string>();
const playlistMetadata = new Map<string, PlaylistMetadata>();
let ytdlSingleton = false;

app.use(cors(), express.static("dist", {}));

/**
 * Generates metadata for a provided playlist such as total length, a default thumbnail, video count, etc.
 * This is intended to be a wrapper for missing info not generated by the ytdl tool
 * @param playlistData
 */
const generateMetadata = async (playlistData: PlaylistJSON) => {
  if (Object.keys(playlistData.videos).length === 0) return false;
  let totalLength = 0;
  Object.values(playlistData.videos).forEach((v) => {
    if (v.duration) totalLength += v.duration;
  });
  const metadata: PlaylistMetadata = {
    id: playlistData.id,
    videoCount: Object.keys(playlistData.videos).length,
    videosWithSubs: Object.keys(playlistData.subs).filter(
      (s) => playlistData.subs[s].length !== 0
    ).length,
    thumbnail: Object.values(playlistData.videos)[0].thumbnail,
    totalLength: humanizeDuration(1000 * totalLength, { largest: 2 }),
  };

  playlistMetadata.set(playlistData.id, metadata);

  return true;
};

/**
 * Checks for existing playlist folder data, delegates to generate
 * metadata for each and create hashes of each for the auto-update mechanism.
 */
const initPlaylistData = async () => {
  fs.mkdirSync(playlistDirectory, { recursive: true });
  const dir: string[] = fs.readdirSync(playlistDirectory);
  const metadataPromise = [];
  for (const filename of dir) {
    const playlistData: PlaylistJSON = await JSON.parse(
      fs.readFileSync(playlistDirectory + "/" + filename, "utf-8")
    );
    metadataPromise.push(generateMetadata(playlistData));
    playlistHashes.set(filename.split(".json")[0], md5(playlistData.videos));
    playlists.set(filename.split(".json")[0], playlistData);
  }
  await Promise.all(metadataPromise);
};

/**
 * By default checks for any changes in directory data against internal hashes and lists.
 * If any changes are found, data is deleted/generated appropriately.
 *
 * @param id optionally provide a specific playlist ID to check for updates
 */
const checkUpdates = async (id?: string) => {
  let toUpdate: PlaylistJSON[] = [];
  let data;
  // Single video
  if (id) {
    const filename = id + ".json";
    try {
      data = await JSON.parse(
        fs.readFileSync(playlistDirectory + "/" + filename, "utf-8")
      );
    } catch (e) {
      console.error(e);
      return false;
    }

    if (md5(data.videos) !== playlistHashes.get(filename)) {
      playlists.set(filename, data);
      toUpdate.push(data);
    }
  } else {
    // Check updates for all internal data and directory data
    const playlistDir = fs.readdirSync(playlistDirectory);
    const readAsync = playlistDir.map((f) =>
      JSON.parse(fs.readFileSync(playlistDirectory + "/" + f, "utf-8"))
    );
    await Promise.all(readAsync);
    // Check directory data against internal to see if update is necessary due to addition/change
    for (const file of playlistDir) {
      let data = readAsync.find((d) => file === d.id + ".json");
      const filename = file.split(".json")[0];
      const hash = playlistHashes.get(filename);
      if (!hash || md5(data.videos) !== hash) {
        playlists.set(filename, data);
        toUpdate.push(data);
      }
    }
    // Check internal data against directory data to see if anything was removed
    for (const playlist of playlists.keys()) {
      if (!playlistDir.includes(playlist + ".json")) {
        playlists.delete(playlist);
        playlistMetadata.delete(playlist);
        playlistHashes.delete(playlist);
      }
    }
  }

  // Perform async update of all metadata, then return to indicate completion.
  if (toUpdate.length !== 0) {
    const metadataPromise: Promise<boolean>[] = [];
    toUpdate.forEach((data) => {
      metadataPromise.push(generateMetadata(data));
    });
    await Promise.all(metadataPromise);
  }
  return true;
};

export interface PlaylistMetadata {
  id: string;
  videoCount: number;
  videosWithSubs: number;
  totalLength: string;
  thumbnail: string;
}

// ROUTES

/**
 * Retutns an array of all playlist metadata
 * @param req
 * @param res
 */
const getMetadata = (req: Request, res: Response<any>) => {
  checkUpdates()
    .then(() => res.json([...playlistMetadata.values()]))
    .catch((e) => res.status(500).send(e));
};

/**
 * Returns playlist data for a requested playlist ID. The full .json is transmitted.
 * @param req
 * @param res
 */
const getPlaylist = (req: Request, res: Response<any>) => {
  const { id } = req.params;
  if (!playlists.has(id)) {
    res.status(404).send();
    return;
  }
  const playlist = playlists.get(id);

  if (!playlist) {
    res.status(500).send();
    return;
  }
  res.json(playlist);
};

/**
 * Method to request a playlist to be downloaded. This function is clunky, and delegates to ytld.js to
 * download a particular playlist. Work needed to standardise responses between ytdl.js, the server, and
 * the API response.
 * @param req
 * @param res
 */
const requestDownload = (req: Request, res: Response<any>) => {
  const id = req.query.id;
  if (typeof id !== "string") {
    res.status(400).send("Please provide a single ID string");
    return;
  }
  // Only allow one 'instance' of ytdl to be running
  if (ytdlSingleton)
    return res.status(400).json({
      success: false,
      message: "Ytdl download already in progress",
    });
  ytdlSingleton = true;
  YtdlPlaylistDownloader(id)
    .then((playlistId) => {
      if (playlistId) {
        res.json({ success: true, message: playlistId });
      } else {
        res.status(500).json({
          success: false,
          message: "Downloading failed, check server output",
        });
      }
    })
    .catch((e) => {
      console.error(e);
      res.status(500).json({
        success: false,
        message: "Downloading failed, check server output",
        error: e,
      });
    })
    .finally(() => (ytdlSingleton = false));
};

/**
 * Initialise API endpoints. Consider moving to separate file.
 */
const initRoutes = () => {
  app.get("/playlist_metadata", getMetadata);

  app.get("/playlist/:id", getPlaylist);

  app.post("/download", requestDownload);
};

/**
 * Main server function. Intitialist the data, then the routes, then go live.
 */
initPlaylistData()
  .then(initRoutes)
  .then(() => {
    app.listen(port, () => {
      console.log(`server started at http://localhost:${port}`);
    });
  });
